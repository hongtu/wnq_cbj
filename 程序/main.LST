C51 COMPILER V9.52.0.0   MAIN                                                              02/13/2017 09:52:48 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE main.c BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          /*
   2          注意事项
   3          0、上升10mm所需的电机步数，临时设置为600
   4          1、必须有一个全局变量用来统计电机的位置，从初始化之前就开始统计，防止初
             -始化撞机或传感器失效
   5          2、急停接触之后，必须有一个单片机复位初始化的过程，非从0初始化，防止信
             -的继续发送撞机以及非原点运动
   6          */
   7          //除了初始化为 0 的常量或常量外，其他的变量或常量均在此处定义或声明
   8          #include <STC89C5xRC.H>                                                                     //52单片机头文件
   9          #include <stdio.h>                                                                          //基本函数库
  10          #include <math.h>
  11          #include <intrins.h>
  12          #define uchar unsigned char
  13          #define uint  unsigned int
  14          
  15          //检测点
  16          sbit k1 = P2^0;                                                                             //原点检测，光耦检测，端口常输出为
             -，光耦未遮挡，检测为低
  17          sbit ori = P2^1;                                                                            //下极限检测
  18          sbit k3 = P2^2;                                                                             //上极限检测
  19          sbit flag_out = P2^3;                                                                       //出板检测
  20          sbit flag_in  = P2^4;                                                                       //进板检测
  21          
  22          //电机相关的变量
  23          int p_imp;                                                                                  //电机的位置
  24          int a_imp;                                                                                  //临时数据
  25          #define speed_max 8                 //需要注意更改的常量                                   //电机的最大速度
  26          #define speed_start 120             //需要注意更改的常量                                   //启动速度
  27          #define step  601                   //需要注意更改的常量                                   //与电机的驱动步数要匹
             -配
  28          int speed_now;                                                                              //当前速度的变量
  29          
  30          //层高变量
  31          #define floor_max 50                //需要注意更改的常量                                   //最大层数，计数从1开
             -，从顶层开始计
  32          uchar idata floor_now;                                                                      //当前层高 
  33          uchar idata floor_nex;
  34          long  idata floor_t;                                                                        //因为这个数是有符号的，且数字比较
             -大，所以用长整形
  35          uchar idata floor_full;                                                                     //层满标志，空-0 有-1 满-2
  36          
  37          //库存变量
  38          uchar idata flag_ware_i = 0;                                                                //储板箱中从上面数的层数
  39          uchar idata flag_sare_j = 0;                                                                //储板箱中从下面数的层数
  40          uchar idata ware_con[floor_max];                                                            //用于存放每层箱中是否有板，0-
             -板，1-有板
  41          uchar idata ware_opt[floor_max];                                                            //用于记录箱子中板子的优先级
  42          uchar idata ware_opt_num;                                                                   //用于记录优先级的最大数
  43          
  44          //状态变量
  45          idata bit flag_iao;                                                                         //用于标记是否需要存板，0-存板优先
             -1-出板优先。设定好的优先级，会停止使用
  46          idata bit flag_o = 1;                                                                       //原点标志，0-只允许向上运动，1-允
             -上下运动
C51 COMPILER V9.52.0.0   MAIN                                                              02/13/2017 09:52:48 PAGE 2   

  47          idata bit flag_pull = 1;                                                                    //拉板完成标志，0-完成，1-未完成
  48          idata bit flag_push = 1;                                                                    //推板完成标志，0-完成，1-未完成
  49          idata bit flag_safe = 1;                                                                    //安全标志，每次动作前检查一次此
             -志，轮询的方法，不用中断
  50          idata bit flag_up = 1;                                                                      //上板完成标志，0-完成，1-未完成
  51          idata bit flag_down = 1;                                                                    //下板完成标志，0-完成，1-未完成
  52          idata bit flag_t = 1;                                                                       //信息发送完成标志，0-完成，1-未完
             -
  53          idata bit flag_r = 1;                                                                       //信息接收完成标志，0-完成，1-未完
             -
  54          idata bit flag_top = 1;                                                                     //上极限
  55          idata bit flag_bottom = 1;                                                                  //下极限
  56          idata bit flag_ot = 1;                                                                      //超时标志
  57          
  58          void delay_us(long idata time_us)                                                           //延时函数，据实测值推论，延
             -时间为 t*10 + 18 us 
  59          {
  60   1        while(time_us--);      
  61   1      }
  62          
  63          void delay_ms(long idata time_ms)
  64          {
  65   1        int time_ms_add;
  66   1        while(time_ms--)
  67   1        {
  68   2          time_ms_add = 21;
  69   2          while(time_ms_add--);
  70   2        }
  71   1      }
  72          
  73          uchar safe()                                                                                //安全检查
  74          {
  75   1        flag_safe=0;
  76   1        if (flag_o==1) flag_safe=1; else P00 = 0;
  77   1        if (flag_pull==1) flag_safe=1; else P01 = 0;
  78   1        if (flag_push==1) flag_safe=1; else P02 = 0;
  79   1        if (flag_up==1) flag_safe=1; else P03 = 0;
  80   1        if (flag_down==1) flag_safe=1; else P04 = 0;
  81   1        if (flag_top==1) flag_safe=1; else P05 = 0;
  82   1        if (flag_bottom==1) flag_safe=1; else P06 = 0;
  83   1        return flag_safe;
  84   1      }
  85          
  86          void upanddown(floor_nex)                                                                   //上下板函数，传递目标层变量
  87          {
  88   1        long idata length_run;
  89   1        uint idata dir ;
  90   1        //if (safe()==1 && flag_ware==1)
  91   1        //{
  92   1          delay_ms(300);
  93   1          speed_now = speed_start;                                                                //对速度赋初值
  94   1          length_run = floor_nex-floor_now;                                                       //需要运动的层数 = 目的层高 - 
             -前层高
  95   1          floor_t = length_run * step;                                                            //后面的常数代表运动10mm所需的电
             -运转步数，这个值和电机驱动的设置有关
  96   1          if (floor_t > 0){dir = 0x05;}else{dir = 0x01;}                                          //floor_t为正，向上运动，floo
             -r_t为负，向下运动
  97   1          floor_t = abs(floor_t);                                                                 //取绝对值
  98   1          for (length_run = 0;length_run < floor_t;length_run++)
  99   1          {
 100   2            P1 = 0x00;
 101   2            delay_us(speed_now);
C51 COMPILER V9.52.0.0   MAIN                                                              02/13/2017 09:52:48 PAGE 3   

 102   2            P1 = dir;                                                                             //需要运动的方向由dir变量控制
 103   2            delay_us(speed_now);
 104   2            if ((floor_t-length_run)>100){if(speed_now > speed_max)speed_now--;}else speed_now++; //完成加速和
             -减速的功能，缓冲距离100步
 105   2          }
 106   1          floor_now = floor_nex;                                                                  //运动完成后，当前层高 = 目的层高
 107   1        //}
 108   1      }
 109          uint init()                                                                                 //初始化函数
 110          {
 111   1        long idata init_con;
 112   1        speed_now = speed_start;
 113   1        upanddown(2);                                                                             //先向上运动两层，再重新找原点
 114   1        delay_ms(1000);
 115   1        while(ori==0)                                                                             //找到原点以后结束循环
 116   1        {
 117   2          P1=0x00;
 118   2          delay_us(speed_now);
 119   2          P1=0x01;                                                                              //向下运动
 120   2          delay_us(speed_now);
 121   2          a_imp++;
 122   2          if (speed_now > speed_max) speed_now--;
 123   2        }
 124   1        for(init_con=0;init_con<100;init_con++){P1=0x01;delay_us(speed_now++);P1=0x00;delay_us(speed_now);}//找
             -原点以后减速
 125   1        return 1;
 126   1      }
 127          
 128          uchar opt_out()
 129          {
 130   1        long idata count;
 131   1        uchar opt_level;
 132   1        for (count = 0;count < 50;count++)
 133   1        {
 134   2          if ((opt_level < ware_opt[count]) && ware_con != 0)                                         //取a=存板优先级里最小
             -一个
 135   2          {
 136   3            opt_level = ware_opt[count];
 137   3          }
 138   2        }
 139   1        upanddown(count);
 140   1        return 0;
 141   1      }
 142          
 143          uchar opt_in()                                                                              //优化函数
 144          {
 145   1        uchar idata count_up;
 146   1        uchar idata count_down;
 147   1        uchar opt_level;
 148   1        uint a;
 149   1        count_up = floor_now;
 150   1        count_down = floor_now;
 151   1        while(ware_con[count_up])                                                                 //向上查找第一个空层，因计数是从
             -1开始的，所以此处为1
 152   1        {                                                                                         //如果当前层不为空，则执行以下行
 153   2          if(count_up <= 1)                                                                       //如果层数 1  不为空，则将层数变量设
             -置为一个较大的数，并跳出循环
 154   2          {
 155   3            count_up = 999;
 156   3            break;
 157   3          }
 158   2          count_up--;
C51 COMPILER V9.52.0.0   MAIN                                                              02/13/2017 09:52:48 PAGE 4   

 159   2        }
 160   1        
 161   1        while(ware_con[count_down])                                                               //向下查找第一个空层，最大层数
             -量在全局变量定义
 162   1        {
 163   2          if(count_down >= floor_max)
 164   2          {
 165   3            count_down = 999;
 166   3            break;
 167   3          }
 168   2          count_down++;
 169   2        }
 170   1      
 171   1        if(count_up == 999 && count_down == 999)                                                  //如果上下层高标记均为溢出
             -态，则赋层满标记为 满-2
 172   1        {
 173   2          floor_full = 2;
 174   2        }
 175   1        if(floor_full != 2)
 176   1        {
 177   2          if((floor_now - count_up) <= (count_down - floor_now))                                  //找到最近的空层
 178   2          {
 179   3            upanddown(count_up);
 180   3          }
 181   2          else                                                                                    //如果到上面的空层近，则运动到上面的空
             -，反之亦然
 182   2          {
 183   3            upanddown(count_down);
 184   3          }
 185   2          for(a = 0;a <= floor_max;a++)                                                           //查找优先级最大数
 186   2          {
 187   3            if(ware_opt[a] > ware_opt[a-1])
 188   3            {
 189   4              ware_opt_num = ware_opt[a];
 190   4            }
 191   3            else
 192   3            {
 193   4              ware_opt_num = ware_opt[a-1];
 194   4            }
 195   3          }
 196   2          if(pullboard() == 1)
*** WARNING C206 IN LINE 196 OF main.c: 'pullboard': missing function-prototype
 197   2          {
 198   3            ware_con[floor_now] = 1;                                                              //存储完成后，对此层的状态置 1
 199   3            ware_opt[floor_now] = 1;                                                              //存储完成后，对此层的优先级置数
 200   3            return 0;                                                                             //完成返回 0
 201   3          }
 202   2          else
 203   2          {
 204   3            return 1;                                                                             //失败返回 1
 205   3          }
 206   2        }
 207   1        else
 208   1        {
 209   2                                                                                                  //此处做溢出提示
 210   2        }
 211   1      }
*** WARNING C280 IN LINE 147 OF main.c: 'opt_level': unreferenced local variable
 212          
 213          void main()
 214          {
 215   1        P2 = 0xFF;                                                                                //P2口做输入用
C51 COMPILER V9.52.0.0   MAIN                                                              02/13/2017 09:52:48 PAGE 5   

 216   1        if (init() == 1)                                                                          //调用初始化，且初始化完成正确
 217   1        {
 218   2          floor_now = 0;                                                                          //初始化完成后，设定当前层高为 0
 219   2          while(1)                                                                                //主循环函数
 220   2          {
 221   3            if (flag_out == 0 && floor_full != 0)                                                 //出板传感器有信号，且层标记
             -不为空，则执行出板
 222   3            {
 223   4              opt_out();
 224   4            }
 225   3            if (flag_in == 0 && floor_full != 2)                                                  //进板传感器有信号，且层标记
             -为满，则执行进板
 226   3            {
 227   4              opt_in();
 228   4            }
 229   3          }
 230   2        }
 231   1        else                                                                                      //初始化失败以后
 232   1        {
 233   2          while(1)
 234   2          {
 235   3            
 236   3          }
 237   2        }
 238   1      }
*** WARNING C291 IN LINE 211 OF main.c: not every exit path returns a value


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    873    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      6      12
   IDATA SIZE       =    110      16
   BIT SIZE         =     12    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  3 WARNING(S),  0 ERROR(S)
